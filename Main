local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Ducks Hub GUI V1", "DarkTheme")

--MainFE
local MainFE = Window:NewTab("MainFE")
local MainFESection = MainFE:NewSection("MainFE")


MainFESection:NewButton("FE amongus V2", "Makes you an amongus", function()
    local netboost = 1000 --velocity 
--netboost usage: 
--set to false to disable
--set to a vector3 value if you dont want the velocity to change
--set to a number to change the velocity in real time with magnitude equal to the number
local idleMag = 0.005 --used only in case netboost is set to a number value
--if magnitude of the real velocity of a part is lower than this
--then the fake velocity is being set to Vector3.new(0, netboost, 0)
--the lower value the less you jitter but you might loose network ownership
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false
local hedafterneck = true --disable aligns for head and enable after neck is removed

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
    return
end

for i, v in pairs(c:GetDescendants()) do
    if v:IsA("CharacterMesh") or v:IsA("SpecialMesh") then
        v:Destroy()
    end
end

c:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (c and c.Parent) then
        c = nil
    end
end)

local function gp(parent, name, className)
	local ret = nil
	pcall(function()
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
				break
			end
		end
	end)
	return ret
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
    	local ape = Instance.new("AlignPosition", att0)
    	ape.ApplyAtCenterOfMass = false
    	ape.MaxForce = inf
    	ape.MaxVelocity = inf
    	ape.ReactionForceEnabled = false
    	ape.Responsiveness = 200
    	ape.Attachment1 = att1
    	ape.Attachment0 = att0
    	ape.Name = "AlignPositionRtrue"
    	ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
    	local apd = Instance.new("AlignPosition", att0)
    	apd.ApplyAtCenterOfMass = false
    	apd.MaxForce = inf
    	apd.MaxVelocity = inf
    	apd.ReactionForceEnabled = false
    	apd.Responsiveness = 200
    	apd.Attachment1 = att1
    	apd.Attachment0 = att0
    	apd.Name = "AlignPositionRfalse"
    	apd.RigidityEnabled = false
    end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

    if netboost then
        Part0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (Part0 and Part0.Parent) then
                Part0 = nil
            end
        end)
        spawn(function()
            if typeof(netboost) == "Vector3" then
    	        local vel = v3_0
    	        local rotvel = v3_0
            	while Part0 do
                    Part0.Velocity = vel
                    Part0.RotVelocity = rotvel
                    heartbeat:Wait()
                    if Part0 then
                        vel = Part0.Velocity
                        Part0.Velocity = netboost
                        Part0.RotVelocity = v3_0
                        stepped:Wait()
                    end
                end
        	elseif typeof(netboost) == "number" then
    	        local vel = v3_0
    	        local rotvel = v3_0
            	while Part0 do
                    Part0.Velocity = vel
                    Part0.RotVelocity = rotvel
                    heartbeat:Wait()
                    if Part0 then
                        local newvel = vel
                        local mag = newvel.Magnitude
                        if mag < idleMag then
                            newvel = v3(0, netboost, 0)
                        else
                            local multiplier = netboost / mag
                            newvel *= v3(multiplier,  multiplier, multiplier)
                        end
                        vel = Part0.Velocity
                        rotvel = Part0.RotVelocity
                        Part0.Velocity = newvel
                        Part0.RotVelocity = v3_0
                        stepped:Wait()
                    end
                end
        	end
        end)
    end
end

local function respawnrequest()
    local c = lp.Character
    local ccfr = ws.CurrentCamera.CFrame
	local fc = Instance.new("Model")
	local nh = Instance.new("Humanoid", fc)
	lp.Character = fc
	nh.Health = 0
	lp.Character = c
	fc:Destroy()
    local con = nil
    local function confunc()
        con:Disconnect()
        ws.CurrentCamera.CFrame = ccfr
    end
    con = renderstepped:Connect(confunc)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

addtools = addtools and gp(lp, "Backpack", "Backpack")

if simradius == "shp" then
    local shp = sethiddenproperty or set_hidden_property or set_hidden_prop or sethiddenprop
    if shp then
        spawn(function()
            while c and heartbeat:Wait() do
                shp(lp, "SimulationRadius", inf)
            end
        end)
    end
elseif simradius == "ssr" then
    local ssr = setsimulationradius or set_simulation_radius or set_sim_radius or setsimradius or set_simulation_rad or setsimulationrad
    if ssr then
        spawn(function()
            while c and heartbeat:Wait() do
                ssr(inf)
            end
        end)
    end
end

antiragdoll = antiragdoll and function(v)
    if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
        v.Parent = nil
    end
end

if antiragdoll then
    for i, v in pairs(c:GetDescendants()) do
        antiragdoll(v)
    end
    c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
    respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
	    return
	end
end

if discharscripts then
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("LocalScript") then
            v.Disabled = true
        end
    end
elseif newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate and (not animate.Disabled) then
        animate.Disabled = true
    else
        newanimate = false
    end
end

local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
    for i, v in pairs(hum:GetPlayingAnimationTracks()) do
	    v:Stop()
    end
end

if addtools then
    for i, v in pairs(addtools:GetChildren()) do
        if v:IsA("Tool") then
            v.Parent = c
        end
    end
end

pcall(function()
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
	    local newName = tostring(i)
	    local exists = true
	    while exists do
		    exists = false
		    for i, v in pairs(OLDscripts) do
		        if v.Name == newName then
		            exists = true
		        end
		    end
		    if exists then
		        newName = newName .. "_"    
		    end
	    end
        table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local cl = c:Clone()
for i, v in pairs(cl:GetDescendants()) do
    pcall(function()
        v.Transparency = 1
        v.Anchored = false
    end)
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (model and model.Parent) then
        model = nil
    end
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
	    if destroyhum and v:IsA("Humanoid") then
	        v:Destroy()
	    else
	        if addtools and v:IsA("Tool") then
	            for i1, v1 in pairs(v:GetDescendants()) do
	                if v1 and v1.Parent and v1:IsA("BasePart") then
	                    local bv = Instance.new("BodyVelocity", v1)
	                    bv.Velocity = v3_0
	                    bv.MaxForce = v3(1000, 1000, 1000)
	                    bv.P = 1250
	                    bv.Name = "bv_" .. v.Name
	                end
	            end
	        end
		    v.Parent = model
	    end
	end
end
local head = gp(model, "Head", "BasePart")
local torso = gp(model, "Torso", "BasePart") or gp(model, "UpperTorso", "BasePart")
if breakjoints then
    model:BreakJoints()
else
    if head and torso then
        for i, v in pairs(model:GetDescendants()) do
            if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
                local save = false
                if (v.Part0 == torso) and (v.Part1 == head) then
                    save = true
                end
                if (v.Part0 == head) and (v.Part1 == torso) then
                    save = true
                end
                if save then
                    if hedafterneck then
                        hedafterneck = v
                    end
                else
                    v:Destroy()
                end
            end
        end
    end
    if method == 3 then
        spawn(function()
            wait(loadtime)
            if model then
                model:BreakJoints()
            end
        end)
    end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
    if v:IsA("BasePart") then
        i = tostring(i)
        local con = nil
        con = v:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (v and v.Parent) then
                con:Disconnect()
                modelDes[i] = nil
            end
        end)
        modelDes[i] = v
    end
end
local modelcolcon = nil
local function modelcolf()
    if model then
        for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
    else
        modelcolcon:Disconnect()
    end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head and head.Parent then
    local aligns = {}
    for i, v in pairs(head:GetDescendants()) do
        if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
            table.insert(aligns, v)
            v.Enabled = false
        end
    end
    spawn(function()
        while c and hedafterneck and hedafterneck.Parent do
            stepped:Wait()
        end
        if not (c and head and head.Parent) then
            return
        end
        for i, v in pairs(aligns) do
            pcall(function()
                v.Enabled = true
            end)
        end
    end)
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
			    v.Transparency = 1
			elseif v:IsA("ForceField") then
			    v.Visible = false
			elseif v:IsA("Sound") then
			    v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate then
        animate.Disabled = false
    end
end

if addtools then
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("Tool") then
            v.Parent = addtools
        end
    end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    ws.CurrentCamera.CameraSubject = hum1
    local camSubCon = nil
    local function camSubFunc()
        camSubCon:Disconnect()
        if c and hum1 and (hum1.Parent == c) then
            ws.CurrentCamera.CameraSubject = hum1
        end
    end
    camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if (prop == "Jump") and hum1 and hum1.Parent then
				hum1.Jump = hum0.Jump
			end
		end)
	else
	    lp.Character = nil
	    lp.Character = c
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
	    c:BreakJoints()
	    return
	end
	if antirespawn then
	    if hum0 and hum0.Parent and (hum0.Health > 0) then
	        model:BreakJoints()
	        hum0.Health = 0
	    end
		respawnrequest()
	else
	    if hum0 and hum0.Parent and (hum0.Health > 0) then
	        model:BreakJoints()
	        hum0.Health = 0
	    end
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum0.Parent and hum1 and hum1.Parent then
            hum1.Jump = hum0.Jump
        end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
	local cfr = nil
	pcall(function()
		cfr = gp(c, "HumanoidRootPart", "BasePart").CFrame
	end)
	if cfr then
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.85,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.85,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		for i, v in pairs(R6parts) do
			local part = Instance.new("Part")
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
				    if att then
				        att.Parent = part
				        att.Position = v3(0, v1, 0)
				    end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end

wait()
if not c then
    return
end

local venttoggle = false
local vented = false
local mode2 = false
local attack = false
local modetoggle = false
local dead = false
local dtoggle = false
local sittoggle = false
local sit = false
local sine = 0
local mouse = lp:GetMouse()

local joints = {
    ["RootJoint"] = "",
    ["Neck"] = "",
    ["Right Hip"] = "",
    ["Left Hip"] = "",
    ["Left Shoulder"] = "",
    ["Right Shoulder"] = ""
}

for i, v in pairs(c:GetDescendants()) do
    if v:IsA("Motor6D") and (joints[v.Name] == "") and (not v:IsDescendantOf(model)) then
        joints[v.Name] = v
    end
end

for i, v in pairs(joints) do
    if v and (v ~= "") then
        v.C0 = cf(0, 0, 0)
        v.C1 = cf(0, 0, 0)
    else
        return
    end
end

local Root = gp(c, "HumanoidRootPart", "BasePart")
if not Root then
    return
end

local function replace(a)
    local b, c = a.Part0, a.Part1
    a.Part1, a.Part0 = b, c
end

replace(joints["Left Shoulder"])
replace(joints["Right Shoulder"])
replace(joints["Left Hip"])
replace(joints["Right Hip"])

for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") then
        v:Destroy()
    end
end

joints.Neck.C0 = cf(0, 0.3, -0.5)

mouse.Button1Down:Connect(function()
    if not (kill or mode2 or dead) then
        attack = true
        vented = false
        hum1.WalkSpeed = 0
        wait(0.5)
        hum1.WalkSpeed = 16
        attack = false
    end
end)

mouse.KeyDown:Connect(function(key)
    if not c then 
        return 
    end
    key = key:lower()
    if k == "e" then
        if not venttoggle then
            modetoggle = false
            mode2 = false
            venttoggle = true
            vented = true
            hum1.WalkSpeed = 100
            position = "ventidle"
        elseif venttoggle then
            venttoggle = false
            vented = false
            hum1.WalkSpeed = 16
        end
    elseif key == "f" then
        if not modetoggle then
            venttoggle = false
            vented = false
            modetoggle = true
            mode2 = true
            sittoggle = false
            sit = false
            hum1.WalkSpeed = 60
        elseif modetoggle then
            modetoggle = false
            mode2 = false
            hum1.WalkSpeed = 16
        end
    elseif key == "q" then
        if dtoggle == false then
            venttoggle = false
            vented = false
            modetoggle = false
            mode2 = false
            dtoggle = true
            dead = true
            sittoggle = false
            sit = false
            hum1.WalkSpeed = 0
        elseif dtoggle == true then
            dtoggle = false
            dead = false
            hum1.WalkSpeed = 16
        end
    elseif key == "c" then
        if sittoggle == false then
            venttoggle = false
            vented = false
            modetoggle = false
            mode2 = false
            dtoggle = false
            dead = false
            sittoggle = true
            sit = true
            hum1.WalkSpeed = 0
        elseif sittoggle == true then
            sittoggle = false
            sit = false
            hum1.WalkSpeed = 16
        end
    end
end)

local pose = "idle"
while stepped:Wait() and c do
    if attack then
        pose = "attack"
    elseif dead then
        pose = "dead"
    elseif sit then
        pose = "sit"
    elseif mode2 then
        if Root.Velocity.Magnitude < 2 then
            pose = "idle2"
        elseif Root.Velocity.Magnitude > 20 then
            pose = "walk2"
        end
    else
        if Root.Velocity.y > 1 then
            pose = "jump"
        elseif Root.Velocity.y < -1 then
            pose = "fall"
        elseif Root.Velocity.Magnitude < 2 then
            pose = "idle"
        elseif Root.Velocity.Magnitude < 20 then
            pose = "walk"
        elseif Root.Velocity.Magnitude > 20 then
            pose = "run"
        end 
    end
    sine += 1
    if pose == "idle" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/12), 0 + 0.3 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 10 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.5 + 0 * math.sin(sine/12), 2 + 0.3 * math.sin(sine/12), 0.3 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 10 * math.sin(sine/12)), math.rad(20 + 0 * math.sin(sine/12)), math.rad(-3 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/12), 2 + 0.3 * math.sin(sine/12), 0.3 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 10 * math.sin(sine/12)), math.rad(-20 + 0 * math.sin(sine/12)), math.rad(3 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "walk" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/12), 0 + 0.3 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(-10 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.5 + 0 * math.sin(sine/12), 2 + 0.3 * math.sin(sine/12), 0.3 + 0.3 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 30 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/12), 2 + 0.3 * math.sin(sine/12), 0.3 + -0.3 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + -30 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "jump" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.5 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(15 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/12), 1 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(10 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "fall" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.5 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(15 + 10 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(-10 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/12), 1 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(10 + 5 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(10 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "vent" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/12), 0 + -8 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.5 + 0 * math.sin(sine/12), 1.5 + 0 * math.sin(sine/12), 1 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(26.02 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/12), 2 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "ventidle" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/12), -20 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.5 + 0 * math.sin(sine/12), 1.5 + 0 * math.sin(sine/12), 1 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(26.02 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/12), 2 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "idle2" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/20), 3 + 0.3 * math.sin(sine/20), 0 + 0 * math.sin(sine/20)) * CFrame.Angles(math.rad(0 + 20 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.5 + 0 * math.sin(sine/20), 1 + 0 * math.sin(sine/20), 1 + 0 * math.sin(sine/20)) * CFrame.Angles(math.rad(20 + -20 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/20), 2 + 0 * math.sin(sine/20), 0.5 + -0.5 * math.sin(sine/20)) * CFrame.Angles(math.rad(10 + -20 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20))),0.1)
    elseif pose == "walk2" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/20), 3 + 0.3 * math.sin(sine/20), 0 + 0 * math.sin(sine/20)) * CFrame.Angles(math.rad(-60 + 10 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.4 + 0 * math.sin(sine/20), 2 + 0 * math.sin(sine/20), 0.3 + 0 * math.sin(sine/20)) * CFrame.Angles(math.rad(0 + -10 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20)), math.rad(-5 + 0 * math.sin(sine/20))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.5 + 0 * math.sin(sine/20), 1 + 0 * math.sin(sine/20), 0.5 + 0 * math.sin(sine/20)) * CFrame.Angles(math.rad(0 + -20 * math.sin(sine/20)), math.rad(0 + 0 * math.sin(sine/20)), math.rad(5 + 0 * math.sin(sine/20))),0.1)
    elseif pose == "attack" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/5), 0 + 0 * math.sin(sine/5), 0 + 0 * math.sin(sine/5)) * CFrame.Angles(math.rad(30 + 0 * math.sin(sine/5)), math.rad(0 + 0 * math.sin(sine/5)), math.rad(0 + 0 * math.sin(sine/5))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.4 + 0 * math.sin(sine/12), 2 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(30 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(-4 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.4 + 0 * math.sin(sine/12), 2 + 0 * math.sin(sine/12), 0.5 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(30 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(4 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "sit" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/5), -1.8 + 0 * math.sin(sine/5), 0 + 0 * math.sin(sine/5)) * CFrame.Angles(math.rad(10 + 0 * math.sin(sine/5)), math.rad(0 + 0 * math.sin(sine/5)), math.rad(0 + 0 * math.sin(sine/5))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.4 + 0 * math.sin(sine/12), 1 + 0 * math.sin(sine/12), -1 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(-90 + 0 * math.sin(sine/12)), math.rad(10 + 0 * math.sin(sine/12)), math.rad(-4 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.4 + 0 * math.sin(sine/12), 1 + 0 * math.sin(sine/12), -1 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(-90 + 0 * math.sin(sine/12)), math.rad(-10 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
    elseif pose == "dead" then
        joints["RootJoint"].C0 = joints["RootJoint"].C0:lerp(CFrame.new(0 + 0 * math.sin(sine/5), -2.5 + 0 * math.sin(sine/5), -1 + 0 * math.sin(sine/5)) * CFrame.Angles(math.rad(-90 + 0 * math.sin(sine/5)), math.rad(0 + 0 * math.sin(sine/5)), math.rad(0 + 0 * math.sin(sine/5))),0.1)
        joints["Right Hip"].C0 = joints["Right Hip"].C0:lerp(CFrame.new(-0.4 + 0 * math.sin(sine/12), 3 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(-4 + 0 * math.sin(sine/12))),0.1)
        joints["Left Hip"].C0 = joints["Left Hip"].C0:lerp(CFrame.new(0.4 + 0 * math.sin(sine/12), 3 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(4 + 0 * math.sin(sine/12))),0.1)
    end
    joints["Right Shoulder"].C0 = joints["Right Shoulder"].C0:lerp(CFrame.new(-0.4 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12), -0.8 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
    joints["Left Shoulder"].C0 = joints["Left Shoulder"].C0:lerp(CFrame.new(0.4 + 0 * math.sin(sine/12), 0 + 0 * math.sin(sine/12), -0.8 + 0 * math.sin(sine/12)) * CFrame.Angles(math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12)), math.rad(0 + 0 * math.sin(sine/12))),0.1)
end
end)

MainFESection:NewButton("infinite yield", "An OP admin panel that gives fly, btools client side, tools, and much more", function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)

MainFESection:NewButton("FE floppa", "this turns you into floppa", function()
    if "floppa says MyWorlds reanimate is good" then
        --reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
        local Vector3_101 = Vector3.new(1, 0, 1)
        local netless_Y = Vector3.new(0, 25.1, 0)
        local function getNetlessVelocity(realPartVelocity) --edit this if you have a better netless method
            local netlessVelocity = realPartVelocity * Vector3_101
            local mag = netlessVelocity.Magnitude
            if mag > 0.1 then
                netlessVelocity *= 100 / mag
            end
            netlessVelocity += netless_Y
            return netlessVelocity
        end
        local simradius = "shp" --simulation radius (net bypass) method
        --"shp" - sethiddenproperty
        --"ssr" - setsimulationradius
        --false - disable
        local noclipAllParts = true --set it to true if you want noclip
        local flingpart = "HumanoidRootPart" --the part that will be used to fling (ctrl + F "fling function")
        local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
        local newanimate = false --disables the animate script and enables after reanimation
        local discharscripts = true --disables all localScripts parented to your character before reanimation
        local R15toR6 = true --tries to convert your character to r6 if its r15
        local hatcollide = false --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
        local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
        local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
        local hedafterneck = true --disable aligns for head and enable after neck is removed
        local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
        local method = 3 --reanimation method
        --methods:
        --0 - breakJoints (takes [loadtime] seconds to laod)
        --1 - limbs
        --2 - limbs + anti respawn
        --3 - limbs + breakJoints after [loadtime] seconds
        --4 - remove humanoid + breakJoints
        --5 - remove humanoid + limbs
        local alignmode = 2 --AlignPosition mode
        --modes:
        --1 - AlignPosition rigidity enabled true
        --2 - 2 AlignPositions rigidity enabled both true and false
        --3 - AlignPosition rigidity enabled false
        
        local lp = game:GetService("Players").LocalPlayer
        local rs = game:GetService("RunService")
        local stepped = rs.Stepped
        local heartbeat = rs.Heartbeat
        local renderstepped = rs.RenderStepped
        local sg = game:GetService("StarterGui")
        local ws = game:GetService("Workspace")
        local cf = CFrame.new
        local v3 = Vector3.new
        local v3_0 = v3(0, 0, 0)
        local inf = math.huge
        
        local c = lp.Character
        
        if not (c and c.Parent) then
            return
        end
        
        c.Destroying:Connect(function()
            c = nil
        end)
        
        local function gp(parent, name, className)
            if typeof(parent) == "Instance" then
                for i, v in pairs(parent:GetChildren()) do
                    if (v.Name == name) and v:IsA(className) then
                        return v
                    end
                end
            end
            return nil
        end
        
        local function align(Part0, Part1)
            Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)
        
            local att0 = Instance.new("Attachment", Part0)
            att0.Orientation = v3_0
            att0.Position = v3_0
            att0.Name = "att0_" .. Part0.Name
            local att1 = Instance.new("Attachment", Part1)
            att1.Orientation = v3_0
            att1.Position = v3_0
            att1.Name = "att1_" .. Part1.Name
        
            if (alignmode == 1) or (alignmode == 2) then
                local ape = Instance.new("AlignPosition", att0)
                ape.ApplyAtCenterOfMass = false
                ape.MaxForce = inf
                ape.MaxVelocity = inf
                ape.ReactionForceEnabled = false
                ape.Responsiveness = 200
                ape.Attachment1 = att1
                ape.Attachment0 = att0
                ape.Name = "AlignPositionRtrue"
                ape.RigidityEnabled = true
            end
        
            if (alignmode == 2) or (alignmode == 3) then
                local apd = Instance.new("AlignPosition", att0)
                apd.ApplyAtCenterOfMass = false
                apd.MaxForce = inf
                apd.MaxVelocity = inf
                apd.ReactionForceEnabled = false
                apd.Responsiveness = 200
                apd.Attachment1 = att1
                apd.Attachment0 = att0
                apd.Name = "AlignPositionRfalse"
                apd.RigidityEnabled = false
            end
        
            local ao = Instance.new("AlignOrientation", att0)
            ao.MaxAngularVelocity = inf
            ao.MaxTorque = inf
            ao.PrimaryAxisOnly = false
            ao.ReactionTorqueEnabled = false
            ao.Responsiveness = 200
            ao.Attachment1 = att1
            ao.Attachment0 = att0
            ao.RigidityEnabled = false
        
            if type(getNetlessVelocity) == "function" then
                local realVelocity = v3_0
                local steppedcon = stepped:Connect(function()
                    Part0.Velocity = realVelocity
                end)
                local heartbeatcon = heartbeat:Connect(function()
                    realVelocity = Part0.Velocity
                    Part0.Velocity = getNetlessVelocity(realVelocity)
                end)
                Part0.Destroying:Connect(function()
                    Part0 = nil
                    steppedcon:Disconnect()
                    heartbeatcon:Disconnect()
                end)
            end
        end
        
        local function respawnrequest()
            local ccfr = ws.CurrentCamera.CFrame
            local c = lp.Character
            lp.Character = nil
            lp.Character = c
            local con = nil
            con = ws.CurrentCamera.Changed:Connect(function(prop)
                if (prop ~= "Parent") and (prop ~= "CFrame") then
                    return
                end
                ws.CurrentCamera.CFrame = ccfr
                con:Disconnect()
            end)
        end
        
        local destroyhum = (method == 4) or (method == 5)
        local breakjoints = (method == 0) or (method == 4)
        local antirespawn = (method == 0) or (method == 2) or (method == 3)
        
        hatcollide = hatcollide and (method == 0)
        
        addtools = addtools and gp(lp, "Backpack", "Backpack")
        
        local fenv = getfenv()
        local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
        local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad
        
        if shp and (simradius == "shp") then
            spawn(function()
                while c and heartbeat:Wait() do
                    shp(lp, "SimulationRadius", inf)
                end
            end)
        elseif ssr and (simradius == "ssr") then
            spawn(function()
                while c and heartbeat:Wait() do
                    ssr(inf)
                end
            end)
        end
        
        antiragdoll = antiragdoll and function(v)
            if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
                v.Parent = nil
            end
        end
        
        if antiragdoll then
            for i, v in pairs(c:GetDescendants()) do
                antiragdoll(v)
            end
            c.DescendantAdded:Connect(antiragdoll)
        end
        
        if antirespawn then
            respawnrequest()
        end
        
        if method == 0 then
            wait(loadtime)
            if not c then
                return
            end
        end
        
        if discharscripts then
            for i, v in pairs(c:GetChildren()) do
                if v:IsA("LocalScript") then
                    v.Disabled = true
                end
            end
        elseif newanimate then
            local animate = gp(c, "Animate", "LocalScript")
            if animate and (not animate.Disabled) then
                animate.Disabled = true
            else
                newanimate = false
            end
        end
        
        if addtools then
            for i, v in pairs(addtools:GetChildren()) do
                if v:IsA("Tool") then
                    v.Parent = c
                end
            end
        end
        
        pcall(function()
            settings().Physics.AllowSleep = false
            settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
        end)
        
        local OLDscripts = {}
        
        for i, v in pairs(c:GetDescendants()) do
            if v.ClassName == "Script" then
                table.insert(OLDscripts, v)
            end
        end
        
        local scriptNames = {}
        
        for i, v in pairs(c:GetDescendants()) do
            if v:IsA("BasePart") then
                local newName = tostring(i)
                local exists = true
                while exists do
                    exists = false
                    for i, v in pairs(OLDscripts) do
                        if v.Name == newName then
                            exists = true
                        end
                    end
                    if exists then
                        newName = newName .. "_"    
                    end
                end
                table.insert(scriptNames, newName)
                Instance.new("Script", v).Name = newName
            end
        end
        
        c.Archivable = true
        local hum = c:FindFirstChildOfClass("Humanoid")
        if hum then
            for i, v in pairs(hum:GetPlayingAnimationTracks()) do
                v:Stop()
            end
        end
        local cl = c:Clone()
        if hum and humState16 then
            hum:ChangeState(Enum.HumanoidStateType.Physics)
            if destroyhum then
                wait(1.6)
            end
        end
        if hum and hum.Parent and destroyhum then
            hum:Destroy()
        end
        
        if not c then
            return
        end
        
        local head = gp(c, "Head", "BasePart")
        local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
        local root = gp(c, "HumanoidRootPart", "BasePart")
        if hatcollide and c:FindFirstChildOfClass("Accessory") then
            local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
            if not (torso and root and anything) then
                return
            end
            torso:Destroy()
            root:Destroy()
            if shp then
                for i,v in pairs(c:GetChildren()) do
                    if v:IsA("Accessory") then
                        shp(v, "BackendAccoutrementState", 0)
                    end 
                end
            end
            anything:Destroy()
        end
        
        for i, v in pairs(cl:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Transparency = 1
                v.Anchored = false
            end
        end
        
        local model = Instance.new("Model", c)
        model.Name = model.ClassName
        
        model.Destroying:Connect(function()
            model = nil
        end)
        
        for i, v in pairs(c:GetChildren()) do
            if v ~= model then
                if addtools and v:IsA("Tool") then
                    for i1, v1 in pairs(v:GetDescendants()) do
                        if v1 and v1.Parent and v1:IsA("BasePart") then
                            local bv = Instance.new("BodyVelocity", v1)
                            bv.Velocity = v3_0
                            bv.MaxForce = v3(1000, 1000, 1000)
                            bv.P = 1250
                            bv.Name = "bv_" .. v.Name
                        end
                    end
                end
                if v:IsA("CharacterMesh") then
                    v:Destroy()
                else
                    v.Parent = model
                end
            end
        end
        
        if breakjoints then
            model:BreakJoints()
        else
            if head and torso then
                for i, v in pairs(model:GetDescendants()) do
                    if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
                        local save = false
                        if (v.Part0 == torso) and (v.Part1 == head) then
                            save = true
                        end
                        if (v.Part0 == head) and (v.Part1 == torso) then
                            save = true
                        end
                        if save then
                            if hedafterneck then
                                hedafterneck = v
                            end
                        else
                            v:Destroy()
                        end
                    end
                end
            end
            if method == 3 then
                spawn(function()
                    wait(loadtime)
                    if model then
                        model:BreakJoints()
                    end
                end)
            end
        end
        
        cl.Parent = c
        for i, v in pairs(cl:GetChildren()) do
            v.Parent = c
        end
        cl:Destroy()
        
        local noclipmodel = (noclipAllParts and c) or model
        local noclipcon = nil
        local function uncollide()
            if noclipmodel then
                for i, v in pairs(noclipmodel:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanCollide = false
                    end
                end
            else
                noclipcon:Disconnect()
            end
        end
        noclipcon = stepped:Connect(uncollide)
        uncollide()
        
        for i, scr in pairs(model:GetDescendants()) do
            if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
                local Part0 = scr.Parent
                if Part0:IsA("BasePart") then
                    for i1, scr1 in pairs(c:GetDescendants()) do
                        if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
                            local Part1 = scr1.Parent
                            if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
                                align(Part0, Part1)
                                break
                            end
                        end
                    end
                end
            end
        end
        
        if (typeof(hedafterneck) == "Instance") and head then
            local aligns = {}
            local con = nil
            con = hedafterneck.Changed:Connect(function(prop)
                if (prop == "Parent") and not hedafterneck.Parent then
                    con:Disconnect()
                    for i, v in pairs(aligns) do
                        v.Enabled = true
                    end
                end
            end)
            for i, v in pairs(head:GetDescendants()) do
                if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
                    i = tostring(i)
                    aligns[i] = v
                    v.Destroying:Connect(function()
                        aligns[i] = nil
                    end)
                    v.Enabled = false
                end
            end
        end
        
        for i, v in pairs(c:GetDescendants()) do
            if v and v.Parent then
                if v.ClassName == "Script" then
                    if table.find(scriptNames, v.Name) then
                        v:Destroy()
                    end
                elseif not v:IsDescendantOf(model) then
                    if v:IsA("Decal") then
                        v.Transparency = 1
                    elseif v:IsA("ForceField") then
                        v.Visible = false
                    elseif v:IsA("Sound") then
                        v.Playing = false
                    elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
                        v.Enabled = false
                    end
                end
            end
        end
        
        if newanimate then
            local animate = gp(c, "Animate", "LocalScript")
            if animate then
                animate.Disabled = false
            end
        end
        
        if addtools then
            for i, v in pairs(c:GetChildren()) do
                if v:IsA("Tool") then
                    v.Parent = addtools
                end
            end
        end
        
        local hum0 = model:FindFirstChildOfClass("Humanoid")
        if hum0 then
            hum0.Destroying:Connect(function()
                hum0 = nil
            end)
        end
        
        local hum1 = c:FindFirstChildOfClass("Humanoid")
        if hum1 then
            hum1.Destroying:Connect(function()
                hum1 = nil
            end)
        end
        
        if hum1 then
            ws.CurrentCamera.CameraSubject = hum1
            local camSubCon = nil
            local function camSubFunc()
                camSubCon:Disconnect()
                if c and hum1 then
                    ws.CurrentCamera.CameraSubject = hum1
                end
            end
            camSubCon = renderstepped:Connect(camSubFunc)
            if hum0 then
                hum0.Changed:Connect(function(prop)
                    if hum1 and (prop == "Jump") then
                        hum1.Jump = hum0.Jump
                    end
                end)
            else
                respawnrequest()
            end
        end
        
        local rb = Instance.new("BindableEvent", c)
        rb.Event:Connect(function()
            rb:Destroy()
            sg:SetCore("ResetButtonCallback", true)
            if destroyhum then
                c:BreakJoints()
                return
            end
            if hum0 and (hum0.Health > 0) then
                model:BreakJoints()
                hum0.Health = 0
            end
            if antirespawn then
                respawnrequest()
            end
        end)
        sg:SetCore("ResetButtonCallback", rb)
        
        spawn(function()
            while c do
                if hum0 and hum1 then
                    hum1.Jump = hum0.Jump
                end
                wait()
            end
            sg:SetCore("ResetButtonCallback", true)
        end)
        
        R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
        if R15toR6 then
            local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
            if part then
                local cfr = part.CFrame
                local R6parts = { 
                    head = {
                        Name = "Head",
                        Size = v3(2, 1, 1),
                        R15 = {
                            Head = 0
                        }
                    },
                    torso = {
                        Name = "Torso",
                        Size = v3(2, 2, 1),
                        R15 = {
                            UpperTorso = 0.2,
                            LowerTorso = -0.8
                        }
                    },
                    root = {
                        Name = "HumanoidRootPart",
                        Size = v3(2, 2, 1),
                        R15 = {
                            HumanoidRootPart = 0
                        }
                    },
                    leftArm = {
                        Name = "Left Arm",
                        Size = v3(1, 2, 1),
                        R15 = {
                            LeftHand = -0.85,
                            LeftLowerArm = -0.2,
                            LeftUpperArm = 0.4
                        }
                    },
                    rightArm = {
                        Name = "Right Arm",
                        Size = v3(1, 2, 1),
                        R15 = {
                            RightHand = -0.85,
                            RightLowerArm = -0.2,
                            RightUpperArm = 0.4
                        }
                    },
                    leftLeg = {
                        Name = "Left Leg",
                        Size = v3(1, 2, 1),
                        R15 = {
                            LeftFoot = -0.85,
                            LeftLowerLeg = -0.15,
                            LeftUpperLeg = 0.6
                        }
                    },
                    rightLeg = {
                        Name = "Right Leg",
                        Size = v3(1, 2, 1),
                        R15 = {
                            RightFoot = -0.85,
                            RightLowerLeg = -0.15,
                            RightUpperLeg = 0.6
                        }
                    }
                }
                for i, v in pairs(c:GetChildren()) do
                    if v:IsA("BasePart") then
                        for i1, v1 in pairs(v:GetChildren()) do
                            if v1:IsA("Motor6D") then
                                v1.Part0 = nil
                            end
                        end
                    end
                end
                part.Archivable = true
                for i, v in pairs(R6parts) do
                    local part = part:Clone()
                    part:ClearAllChildren()
                    part.Name = v.Name
                    part.Size = v.Size
                    part.CFrame = cfr
                    part.Anchored = false
                    part.Transparency = 1
                    part.CanCollide = false
                    for i1, v1 in pairs(v.R15) do
                        local R15part = gp(c, i1, "BasePart")
                        local att = gp(R15part, "att1_" .. i1, "Attachment")
                        if R15part then
                            local weld = Instance.new("Weld", R15part)
                            weld.Name = "Weld_" .. i1
                            weld.Part0 = part
                            weld.Part1 = R15part
                            weld.C0 = cf(0, v1, 0)
                            weld.C1 = cf(0, 0, 0)
                            R15part.Massless = true
                            R15part.Name = "R15_" .. i1
                            R15part.Parent = part
                            if att then
                                att.Parent = part
                                att.Position = v3(0, v1, 0)
                            end
                        end
                    end
                    part.Parent = c
                    R6parts[i] = part
                end
                local R6joints = {
                    neck = {
                        Parent = R6parts.torso,
                        Name = "Neck",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.head,
                        C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                        C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
                    },
                    rootJoint = {
                        Parent = R6parts.root,
                        Name = "RootJoint" ,
                        Part0 = R6parts.root,
                        Part1 = R6parts.torso,
                        C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                        C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
                    },
                    rightShoulder = {
                        Parent = R6parts.torso,
                        Name = "Right Shoulder",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.rightArm,
                        C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                        C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
                    },
                    leftShoulder = {
                        Parent = R6parts.torso,
                        Name = "Left Shoulder",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.leftArm,
                        C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                        C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
                    },
                    rightHip = {
                        Parent = R6parts.torso,
                        Name = "Right Hip",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.rightLeg,
                        C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                        C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
                    },
                    leftHip = {
                        Parent = R6parts.torso,
                        Name = "Left Hip" ,
                        Part0 = R6parts.torso,
                        Part1 = R6parts.leftLeg,
                        C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                        C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
                    }
                }
                for i, v in pairs(R6joints) do
                    local joint = Instance.new("Motor6D")
                    for prop, val in pairs(v) do
                        joint[prop] = val
                    end
                    R6joints[i] = joint
                end
                hum1.RigType = Enum.HumanoidRigType.R6
                hum1.HipHeight = 0
            end
        end
        
        --fling function
        --usage: fling([part or CFrame or Vector3], [fling duration (seconds)], [rotation velocity (Vector3)])
        
        local flingpart0 = gp(model, flingpart, "BasePart")
        local flingpart1 = gp(c, flingpart, "BasePart")
        
        local fling = function() end
        if flingpart0 and flingpart1 then
            flingpart0.Destroying:Connect(function()
                flingpart0 = nil
                fling = function() end
            end)
            flingpart1.Destroying:Connect(function()
                flingpart1 = nil
                fling = function() end
            end)
            --flingpart1.Archivable = true
            local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
            local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
            if att0 and att1 then
                fling = function(target, duration, rotVelocity)
                    if (typeof(target) == "Instance" and target:IsA("BasePart")) or (typeof(target) == "CFrame") then
                        target = target.Position
                    elseif typeof(target) ~= "Vector3" then
                        return
                    end
                    if type(duration) ~= number then
                        duration = tonumber(duration) or 0.5
                    end
                    if typeof(rotVelocity) ~= "Vector3" then
                        rotVelocity = v3(20000, 20000, 20000)
                    end
                    if not (target and flingpart0 and flingpart1 and att0 and att1) then
                        return
                    end
                    local flingpart = flingpart0:Clone()
                    flingpart.Transparency = 1
                    flingpart.Size = v3(0.01, 0.01, 0.01)
                    flingpart.CanCollide = false
                    flingpart.Name = "flingpart_" .. flingpart0.Name
                    flingpart.Anchored = true
                    flingpart.Destroying:Connect(function()
                        flingpart = nil
                    end)
                    flingpart.Parent = flingpart1
                    if flingpart0.Transparency > 0.5 then
                        flingpart0.Transparency = 0.5
                    end
                    att1.Parent = flingpart
                    for i, v in pairs(att0:GetChildren()) do
                        if v:IsA("AlignOrientation") then
                            v.Enabled = false
                        end
                    end
                    local con = nil
                    con = heartbeat:Connect(function()
                        if target and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                            flingpart0.RotVelocity = rotVelocity
                            flingpart.Position = target
                        else
                            con:Disconnect()
                        end
                    end)
                    local steppedRotVel = v3(
                        ((target.X > 0) and -1) or 1,
                        ((target.Y > 0) and -1) or 1,
                        ((target.Z > 0) and -1) or 1
                    )
                    local con = nil
                    con = stepped:Connect(function()
                        if target and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                            flingpart0.RotVelocity = steppedRotVel
                            flingpart.Position = target
                        else
                            con:Disconnect()
                        end
                    end)
                    wait(duration)
                    target = nil
                    if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                        return
                    end
                    flingpart0.RotVelocity = v3_0
                    att1.Parent = flingpart1
                    for i, v in pairs(att0:GetChildren()) do
                        if v:IsA("AlignOrientation") then
                            v.Enabled = true
                        end
                    end
                    flingpart:Destroy()
                end
            end
        end
    end
    
    wait()
    
    local c = game:GetService("Players").LocalPlayer.Character
    
    local function gp(parent, name, className)
        if typeof(parent) == "Instance" then
            for i, v in pairs(parent:GetChildren()) do
                if (v.Name == name) and v:IsA(className) then
                    return v
                end
            end
        end
        return nil
    end
    
    local head = gp(c, "Head", "BasePart")
    if not head then return print("head not found") end
    
    local torso = gp(c, "Torso", "BasePart")
    if not torso then return print("torso not found") end
    
    local humanoidRootPart = gp(c, "HumanoidRootPart", "BasePart")
    if not humanoidRootPart then return print("humanoid root part not found") end
    
    local leftArm = gp(c, "Left Arm", "BasePart")
    if not leftArm then return print("left arm not found") end
    
    local rightArm = gp(c, "Right Arm", "BasePart")
    if not rightArm then return print("right arm not found") end
    
    local leftLeg = gp(c, "Left Leg", "BasePart")
    if not leftLeg then return print("left leg not found") end
    
    local rightLeg = gp(c, "Right Leg", "BasePart")
    if not rightLeg then return print("right leg not found") end
    
    --find rig joints
    
    local neck = gp(torso, "Neck", "Motor6D")
    if not neck then return print("neck not found") end
    
    local rootJoint = gp(humanoidRootPart, "RootJoint", "Motor6D")
    if not rootJoint then return print("root joint not found") end
    
    local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
    if not leftShoulder then return print("left shoulder not found") end
    
    local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
    if not rightShoulder then return print("right shoulder not found") end
    
    local leftHip = gp(torso, "Left Hip", "Motor6D")
    if not leftHip then return print("left hip not found") end
    
    local rightHip = gp(torso, "Right Hip", "Motor6D")
    if not rightHip then return print("right hip not found") end
    
    local cf, euler = CFrame.new, CFrame.fromEulerAnglesXYZ
    neck.C0 = cf(0, -0.5, 0.5) * euler(-1.5882496193148399, 0, -3.1590459461097367)
    rootJoint.C0 = cf(0, -3, -0.5) * euler(-1.5882496193148399, 0, -3.1590459461097367)
    leftShoulder.C0 = cf(0, 0.5, 1) * euler(0, -1.5882496193148399, 0)
    rightShoulder.C0 = cf(0, 0.5, 1) * euler(0, 1.5707963267948966, 0)
    leftHip.C0 = cf(-1, 0.9, 0.5) * euler(1.5707963267948966, -1.0471975511965976, 1.5707963267948966)
    rightHip.C0 = cf(0, -0.8, 0.5) * euler(1.5707963267948966, 1.0471975511965976, 1.5707963267948966)
    
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("Accessory") then
            v:Destroy()
        end
    end
    
    local hum1 = c:FindFirstChildOfClass("Humanoid")
    if hum1 then
        game:GetService("Workspace").CurrentCamera.CameraSubject = hum1
        hum1.HipHeight = 1
        hum1.WalkSpeed = 14
        hum1.JumpPower = 0
        hum1.CameraOffset = Vector3.new(0, -3, 0)
    end
end)

MainFESection:NewButton("Creepy Crawler", "everyone will like you", function()
    if "MyWorld reanimate cool" then
        --reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
        local netboost = Vector3.new(0, 45, 0) --velocity 
        --netboost usage: 
        --set to false to disable
        --set to a vector3 value if you dont want the velocity to change
        --set to a number to change the velocity in real time with magnitude equal to the number
        local idleMag = 0.01 --used only in case netboost is set to a number value
        --if magnitude of the real velocity of a part is lower than this
        --then the fake velocity is being set to Vector3.new(0, netboost, 0)
        local noRotVel = true --parts rotation velocity set to Vector3.new(0, 0, 0)
        local simradius = "shp" --simulation radius (net bypass) method
        --"shp" - sethiddenproperty
        --"ssr" - setsimulationradius
        --false - disable
        local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
        local newanimate = true --disables the animate script and enables after reanimation
        local discharscripts = true --disables all localScripts parented to your character before reanimation
        local R15toR6 = true --tries to convert your character to r6 if its r15
        local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
        local hedafterneck = true --disable aligns for head and enable after neck is removed
        local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
        local method = 3 --reanimation method
        --methods:
        --0 - breakJoints (takes [loadtime] seconds to laod)
        --1 - limbs
        --2 - limbs + anti respawn
        --3 - limbs + breakJoints after [loadtime] seconds
        --4 - remove humanoid + breakJoints
        --5 - remove humanoid + limbs
        local alignmode = 2 --AlignPosition mode
        --modes:
        --1 - AlignPosition rigidity enabled true
        --2 - 2 AlignPositions rigidity enabled both true and false
        --3 - AlignPosition rigidity enabled false
        
        local lp = game:GetService("Players").LocalPlayer
        local rs = game:GetService("RunService")
        local stepped = rs.Stepped
        local heartbeat = rs.Heartbeat
        local renderstepped = rs.RenderStepped
        local sg = game:GetService("StarterGui")
        local ws = game:GetService("Workspace")
        local cf = CFrame.new
        local v3 = Vector3.new
        local v3_0 = v3(0, 0, 0)
        local inf = math.huge
        
        local c = lp.Character
        
        if not (c and c.Parent) then
            return
        end
        
        c.Destroying:Connect(function()
            c = nil
        end)
        
        local function gp(parent, name, className)
            if typeof(parent) == "Instance" then
                for i, v in pairs(parent:GetChildren()) do
                    if (v.Name == name) and v:IsA(className) then
                        return v
                    end
                end
            end
            return nil
        end
        
        local function align(Part0, Part1)
            Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)
        
            local att0 = Instance.new("Attachment", Part0)
            att0.Orientation = v3_0
            att0.Position = v3_0
            att0.Name = "att0_" .. Part0.Name
            local att1 = Instance.new("Attachment", Part1)
            att1.Orientation = v3_0
            att1.Position = v3_0
            att1.Name = "att1_" .. Part1.Name
        
            if (alignmode == 1) or (alignmode == 2) then
                local ape = Instance.new("AlignPosition", att0)
                ape.ApplyAtCenterOfMass = false
                ape.MaxForce = inf
                ape.MaxVelocity = inf
                ape.ReactionForceEnabled = false
                ape.Responsiveness = 200
                ape.Attachment1 = att1
                ape.Attachment0 = att0
                ape.Name = "AlignPositionRtrue"
                ape.RigidityEnabled = true
            end
        
            if (alignmode == 2) or (alignmode == 3) then
                local apd = Instance.new("AlignPosition", att0)
                apd.ApplyAtCenterOfMass = false
                apd.MaxForce = inf
                apd.MaxVelocity = inf
                apd.ReactionForceEnabled = false
                apd.Responsiveness = 200
                apd.Attachment1 = att1
                apd.Attachment0 = att0
                apd.Name = "AlignPositionRfalse"
                apd.RigidityEnabled = false
            end
        
            local ao = Instance.new("AlignOrientation", att0)
            ao.MaxAngularVelocity = inf
            ao.MaxTorque = inf
            ao.PrimaryAxisOnly = false
            ao.ReactionTorqueEnabled = false
            ao.Responsiveness = 200
            ao.Attachment1 = att1
            ao.Attachment0 = att0
            ao.RigidityEnabled = false
        
            if netboost then
                local steppedcon = nil
                local heartbeatcon = nil
                Part0.Destroying:Connect(function()
                    Part0 = nil
                    steppedcon:Disconnect()
                    heartbeatcon:Disconnect()
                end)
                local vel = v3_0
                local rotvel = noRotVel and v3_0
                if typeof(netboost) == "Vector3" then
                    steppedcon = stepped:Connect(function()
                        Part0.Velocity = vel
                        if rotvel then
                            Part0.RotVelocity = rotvel
                        end
                    end)
                    heartbeatcon = heartbeat:Connect(function()
                        vel = Part0.Velocity
                        Part0.Velocity = netboost
                        if rotvel then
                            rotvel = Part0.RotVelocity
                            Part0.RotVelocity = v3_0
                        end
                    end)
                elseif typeof(netboost) == "number" then
                    steppedcon = stepped:Connect(function()
                        Part0.Velocity = vel
                        if rotvel then
                            Part0.RotVelocity = rotvel
                        end
                    end)
                    heartbeatcon = heartbeat:Connect(function()
                        vel = Part0.Velocity
                        local newvel = vel
                        local mag = newvel.Magnitude
                        if mag < idleMag then
                            newvel = v3(0, netboost, 0)
                        else
                            local multiplier = netboost / mag
                            newvel *= v3(multiplier,  multiplier, multiplier)
                        end
                        Part0.Velocity = newvel
                        if rotvel then
                            rotvel = Part0.RotVelocity
                            Part0.RotVelocity = v3_0
                        end
                    end)
                end
            end
        end
        
        local function respawnrequest()
            local ccfr = ws.CurrentCamera.CFrame
            local c = lp.Character
            lp.Character = nil
            lp.Character = c
            local con = nil
            con = ws.CurrentCamera.Changed:Connect(function(prop)
                if (prop ~= "Parent") and (prop ~= "CFrame") then
                    return
                end
                ws.CurrentCamera.CFrame = ccfr
                con:Disconnect()
            end)
        end
        
        local destroyhum = (method == 4) or (method == 5)
        local breakjoints = (method == 0) or (method == 4)
        local antirespawn = (method == 0) or (method == 2) or (method == 3)
        
        addtools = addtools and gp(lp, "Backpack", "Backpack")
        
        local fenv = getfenv()
        if simradius == "shp" then
            local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
            if shp then
                spawn(function()
                    while c and heartbeat:Wait() do
                        shp(lp, "SimulationRadius", inf)
                    end
                end)
            end
        elseif simradius == "ssr" then
            local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad
            if ssr then
                spawn(function()
                    while c and heartbeat:Wait() do
                        ssr(inf)
                    end
                end)
            end
        end
        
        antiragdoll = antiragdoll and function(v)
            if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
                v.Parent = nil
            end
        end
        
        if antiragdoll then
            for i, v in pairs(c:GetDescendants()) do
                antiragdoll(v)
            end
            c.DescendantAdded:Connect(antiragdoll)
        end
        
        if antirespawn then
            respawnrequest()
        end
        
        if method == 0 then
            wait(loadtime)
            if not c then
                return
            end
        end
        
        if discharscripts then
            for i, v in pairs(c:GetChildren()) do
                if v:IsA("LocalScript") then
                    v.Disabled = true
                end
            end
        elseif newanimate then
            local animate = gp(c, "Animate", "LocalScript")
            if animate and (not animate.Disabled) then
                animate.Disabled = true
            else
                newanimate = false
            end
        end
        
        local hum = c:FindFirstChildOfClass("Humanoid")
        if hum then
            for i, v in pairs(hum:GetPlayingAnimationTracks()) do
                v:Stop()
            end
        end
        
        if addtools then
            for i, v in pairs(addtools:GetChildren()) do
                if v:IsA("Tool") then
                    v.Parent = c
                end
            end
        end
        
        pcall(function()
            settings().Physics.AllowSleep = false
            settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
        end)
        
        local OLDscripts = {}
        
        for i, v in pairs(c:GetDescendants()) do
            if v.ClassName == "Script" then
                table.insert(OLDscripts, v)
            end
        end
        
        local scriptNames = {}
        
        for i, v in pairs(c:GetDescendants()) do
            if v:IsA("BasePart") then
                local newName = tostring(i)
                local exists = true
                while exists do
                    exists = false
                    for i, v in pairs(OLDscripts) do
                        if v.Name == newName then
                            exists = true
                        end
                    end
                    if exists then
                        newName = newName .. "_"    
                    end
                end
                table.insert(scriptNames, newName)
                Instance.new("Script", v).Name = newName
            end
        end
        
        c.Archivable = true
        local cl = c:Clone()
        for i, v in pairs(cl:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Transparency = 1
                v.Anchored = false
            end
        end
        
        local model = Instance.new("Model", c)
        model.Name = model.ClassName
        
        model.Destroying:Connect(function()
            model = nil
        end)
        
        for i, v in pairs(c:GetChildren()) do
            if v ~= model then
                if destroyhum and v:IsA("Humanoid") then
                    v:Destroy()
                else
                    if addtools and v:IsA("Tool") then
                        for i1, v1 in pairs(v:GetDescendants()) do
                            if v1 and v1.Parent and v1:IsA("BasePart") then
                                local bv = Instance.new("BodyVelocity", v1)
                                bv.Velocity = v3_0
                                bv.MaxForce = v3(1000, 1000, 1000)
                                bv.P = 1250
                                bv.Name = "bv_" .. v.Name
                            end
                        end
                    end
                    v.Parent = model
                end
            end
        end
        local head = gp(model, "Head", "BasePart")
        local torso = gp(model, "Torso", "BasePart") or gp(model, "UpperTorso", "BasePart")
        if breakjoints then
            model:BreakJoints()
        else
            if head and torso then
                for i, v in pairs(model:GetDescendants()) do
                    if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
                        local save = false
                        if (v.Part0 == torso) and (v.Part1 == head) then
                            save = true
                        end
                        if (v.Part0 == head) and (v.Part1 == torso) then
                            save = true
                        end
                        if save then
                            if hedafterneck then
                                hedafterneck = v
                            end
                        else
                            v:Destroy()
                        end
                    end
                end
            end
            if method == 3 then
                spawn(function()
                    wait(loadtime)
                    if model then
                        model:BreakJoints()
                    end
                end)
            end
        end
        
        cl.Parent = c
        for i, v in pairs(cl:GetChildren()) do
            v.Parent = c
        end
        cl:Destroy()
        
        local modelDes = {}
        for i, v in pairs(model:GetDescendants()) do
            if v:IsA("BasePart") then
                i = tostring(i)
                v.Destroying:Connect(function()
                    modelDes[i] = nil
                end)
                modelDes[i] = v
            end
        end
        local modelcolcon = nil
        local function modelcolf()
            if model then
                for i, v in pairs(modelDes) do
                    v.CanCollide = false
                end
            else
                modelcolcon:Disconnect()
            end
        end
        modelcolcon = stepped:Connect(modelcolf)
        modelcolf()
        
        for i, scr in pairs(model:GetDescendants()) do
            if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
                local Part0 = scr.Parent
                if Part0:IsA("BasePart") then
                    for i1, scr1 in pairs(c:GetDescendants()) do
                        if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
                            local Part1 = scr1.Parent
                            if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
                                align(Part0, Part1)
                                break
                            end
                        end
                    end
                end
            end
        end
        
        if (typeof(hedafterneck) == "Instance") and head then
            local aligns = {}
            local con = nil
            con = hedafterneck.Changed:Connect(function(prop)
                if (prop == "Parent") and not hedafterneck.Parent then
                    con:Disconnect()
                    for i, v in pairs(aligns) do
                        v.Enabled = true
                    end
                end
            end)
            for i, v in pairs(head:GetDescendants()) do
                if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
                    i = tostring(i)
                    aligns[i] = v
                    v.Destroying:Connect(function()
                        aligns[i] = nil
                    end)
                    v.Enabled = false
                end
            end
        end
        
        for i, v in pairs(c:GetDescendants()) do
            if v and v.Parent then
                if v.ClassName == "Script" then
                    if table.find(scriptNames, v.Name) then
                        v:Destroy()
                    end
                elseif not v:IsDescendantOf(model) then
                    if v:IsA("Decal") then
                        v.Transparency = 1
                    elseif v:IsA("ForceField") then
                        v.Visible = false
                    elseif v:IsA("Sound") then
                        v.Playing = false
                    elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
                        v.Enabled = false
                    end
                end
            end
        end
        
        if newanimate then
            local animate = gp(c, "Animate", "LocalScript")
            if animate then
                animate.Disabled = false
            end
        end
        
        if addtools then
            for i, v in pairs(c:GetChildren()) do
                if v:IsA("Tool") then
                    v.Parent = addtools
                end
            end
        end
        
        local hum0 = model:FindFirstChildOfClass("Humanoid")
        if hum0 then
            hum0.Destroying:Connect(function()
                hum0 = nil
            end)
        end
        
        local hum1 = c:FindFirstChildOfClass("Humanoid")
        if hum1 then
            hum1.Destroying:Connect(function()
                hum1 = nil
            end)
        end
        
        if hum1 then
            ws.CurrentCamera.CameraSubject = hum1
            local camSubCon = nil
            local function camSubFunc()
                camSubCon:Disconnect()
                if c and hum1 then
                    ws.CurrentCamera.CameraSubject = hum1
                end
            end
            camSubCon = renderstepped:Connect(camSubFunc)
            if hum0 then
                hum0.Changed:Connect(function(prop)
                    if hum1 and (prop == "Jump") then
                        hum1.Jump = hum0.Jump
                    end
                end)
            else
                respawnrequest()
            end
        end
        
        local rb = Instance.new("BindableEvent", c)
        rb.Event:Connect(function()
            rb:Destroy()
            sg:SetCore("ResetButtonCallback", true)
            if destroyhum then
                c:BreakJoints()
                return
            end
            if hum0 and (hum0.Health > 0) then
                model:BreakJoints()
                hum0.Health = 0
            end
            if antirespawn then
                respawnrequest()
            end
        end)
        sg:SetCore("ResetButtonCallback", rb)
        
        spawn(function()
            while c do
                if hum0 and hum1 then
                    hum1.Jump = hum0.Jump
                end
                wait()
            end
            sg:SetCore("ResetButtonCallback", true)
        end)
        
        R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
        if R15toR6 then
            local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
            if part then
                local cfr = part.CFrame
                local R6parts = { 
                    head = {
                        Name = "Head",
                        Size = v3(2, 1, 1),
                        R15 = {
                            Head = 0
                        }
                    },
                    torso = {
                        Name = "Torso",
                        Size = v3(2, 2, 1),
                        R15 = {
                            UpperTorso = 0.2,
                            LowerTorso = -0.8
                        }
                    },
                    root = {
                        Name = "HumanoidRootPart",
                        Size = v3(2, 2, 1),
                        R15 = {
                            HumanoidRootPart = 0
                        }
                    },
                    leftArm = {
                        Name = "Left Arm",
                        Size = v3(1, 2, 1),
                        R15 = {
                            LeftHand = -0.85,
                            LeftLowerArm = -0.2,
                            LeftUpperArm = 0.4
                        }
                    },
                    rightArm = {
                        Name = "Right Arm",
                        Size = v3(1, 2, 1),
                        R15 = {
                            RightHand = -0.85,
                            RightLowerArm = -0.2,
                            RightUpperArm = 0.4
                        }
                    },
                    leftLeg = {
                        Name = "Left Leg",
                        Size = v3(1, 2, 1),
                        R15 = {
                            LeftFoot = -0.85,
                            LeftLowerLeg = -0.15,
                            LeftUpperLeg = 0.6
                        }
                    },
                    rightLeg = {
                        Name = "Right Leg",
                        Size = v3(1, 2, 1),
                        R15 = {
                            RightFoot = -0.85,
                            RightLowerLeg = -0.15,
                            RightUpperLeg = 0.6
                        }
                    }
                }
                for i, v in pairs(c:GetChildren()) do
                    if v:IsA("BasePart") then
                        for i1, v1 in pairs(v:GetChildren()) do
                            if v1:IsA("Motor6D") then
                                v1.Part0 = nil
                            end
                        end
                    end
                end
                part.Archivable = true
                for i, v in pairs(R6parts) do
                    local part = part:Clone()
                    part:ClearAllChildren()
                    part.Name = v.Name
                    part.Size = v.Size
                    part.CFrame = cfr
                    part.Anchored = false
                    part.Transparency = 1
                    part.CanCollide = false
                    for i1, v1 in pairs(v.R15) do
                        local R15part = gp(c, i1, "BasePart")
                        local att = gp(R15part, "att1_" .. i1, "Attachment")
                        if R15part then
                            local weld = Instance.new("Weld", R15part)
                            weld.Name = "Weld_" .. i1
                            weld.Part0 = part
                            weld.Part1 = R15part
                            weld.C0 = cf(0, v1, 0)
                            weld.C1 = cf(0, 0, 0)
                            R15part.Massless = true
                            R15part.Name = "R15_" .. i1
                            R15part.Parent = part
                            if att then
                                att.Parent = part
                                att.Position = v3(0, v1, 0)
                            end
                        end
                    end
                    part.Parent = c
                    R6parts[i] = part
                end
                local R6joints = {
                    neck = {
                        Parent = R6parts.torso,
                        Name = "Neck",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.head,
                        C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                        C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
                    },
                    rootJoint = {
                        Parent = R6parts.root,
                        Name = "RootJoint" ,
                        Part0 = R6parts.root,
                        Part1 = R6parts.torso,
                        C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                        C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
                    },
                    rightShoulder = {
                        Parent = R6parts.torso,
                        Name = "Right Shoulder",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.rightArm,
                        C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                        C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
                    },
                    leftShoulder = {
                        Parent = R6parts.torso,
                        Name = "Left Shoulder",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.leftArm,
                        C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                        C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
                    },
                    rightHip = {
                        Parent = R6parts.torso,
                        Name = "Right Hip",
                        Part0 = R6parts.torso,
                        Part1 = R6parts.rightLeg,
                        C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                        C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
                    },
                    leftHip = {
                        Parent = R6parts.torso,
                        Name = "Left Hip" ,
                        Part0 = R6parts.torso,
                        Part1 = R6parts.leftLeg,
                        C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                        C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
                    }
                }
                for i, v in pairs(R6joints) do
                    local joint = Instance.new("Motor6D")
                    for prop, val in pairs(v) do
                        joint[prop] = val
                    end
                    R6joints[i] = joint
                end
                hum1.RigType = Enum.HumanoidRigType.R6
                hum1.HipHeight = 0
            end
        end
    end
    
    local lp = game:GetService("Players").LocalPlayer
    
    local c = lp.Character
    if not (c and c.Parent) then
        return print("character not found")
    end
    c:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (c and c.Parent) then
            c = nil
        end
    end)
    
    --getPart function
    
    local function gp(parent, name, className)
        local ret = nil
        pcall(function()
            for i, v in pairs(parent:GetChildren()) do
                if (v.Name == name) and v:IsA(className) then
                    ret = v
                    break
                end
            end
        end)
        return ret
    end
    
    --check if reanimate loaded
    
    local model = gp(c, "Model", "Model")
    if not model then return print("model not found") end
    
    --find body parts
    
    local head = gp(c, "Head", "BasePart")
    if not head then return print("head not found") end
    
    local torso = gp(c, "Torso", "BasePart")
    if not torso then return print("torso not found") end
    
    local humanoidRootPart = gp(c, "HumanoidRootPart", "BasePart")
    if not humanoidRootPart then return print("humanoid root part not found") end
    
    local leftArm = gp(c, "Left Arm", "BasePart")
    if not leftArm then return print("left arm not found") end
    
    local rightArm = gp(c, "Right Arm", "BasePart")
    if not rightArm then return print("right arm not found") end
    
    local leftLeg = gp(c, "Left Leg", "BasePart")
    if not leftLeg then return print("left leg not found") end
    
    local rightLeg = gp(c, "Right Leg", "BasePart")
    if not rightLeg then return print("right leg not found") end
    
    --find rig joints
    
    local neck = gp(torso, "Neck", "Motor6D")
    if not neck then return print("neck not found") end
    
    local rootJoint = gp(humanoidRootPart, "RootJoint", "Motor6D")
    if not rootJoint then return print("root joint not found") end
    
    local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
    if not leftShoulder then return print("left shoulder not found") end
    
    local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
    if not rightShoulder then return print("right shoulder not found") end
    
    local leftHip = gp(torso, "Left Hip", "Motor6D")
    if not leftHip then return print("left hip not found") end
    
    local rightHip = gp(torso, "Right Hip", "Motor6D")
    if not rightHip then return print("right hip not found") end
    
    --humanoid
    
    local hum = c:FindFirstChildOfClass("Humanoid")
    if not hum then return print("humanoid not found") end
    
    local animate = gp(c, "Animate", "LocalScript")
    if animate then
        animate.Disabled = true
    end
    
    for i, v in pairs(hum:GetPlayingAnimationTracks()) do
        v:Stop()
    end
    
    --60 fps
    
    local fps = 60
    local event = Instance.new("BindableEvent", c)
    event.Name = "60 fps"
    local floor = math.floor
    fps = 1 / fps
    local tf = 0
    local con = nil
    con = game:GetService("RunService").RenderStepped:Connect(function(s)
        if not c then
            con:Disconnect()
            return
        end
        tf += s
        if tf >= fps then
            for i=1, floor(tf / fps) do
                event:Fire(c)
            end
            tf = 0
        end
    end)
    local event = event.Event
    
    local function stopIfRemoved(instance)
        if not (instance and instance.Parent) then
            c = nil
            return
        end
        instance:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (instance and instance.Parent) then
                c = nil
            end
        end)
    end
    stopIfRemoved(c)
    stopIfRemoved(hum)
    for i, v in pairs({head, torso, leftArm, rightArm, leftLeg, rightLeg, humanoidRootPart}) do
        stopIfRemoved(v)
    end
    for i, v in pairs({neck, rootJoint, leftShoulder, rightShoulder, leftHip, rightHip}) do
        stopIfRemoved(v)
    end
    if not c then
        return
    end
    hum.WalkSpeed = 10
    local cf, v3, euler, sin, sine, abs = CFrame.new, Vector3.new, CFrame.fromEulerAnglesXYZ, math.sin, 0, math.abs
    while event:Wait() do
        sine += 1
        local vel = humanoidRootPart.Velocity
        if (vel*v3(1, 0, 1)).Magnitude > 2 then -- walk
            neck.C0 = neck.C0:Lerp(cf(0, 0, 0.5) * euler(0.17453292519943295, 0.03490658503988659 * sin((sine + 2.5) * 0.2), 3.141592653589793 + -0.17453292519943295 * sin((sine + -10) * 0.2)), 0.2) 
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, -1.5, 0) * euler(3.0543261909900767, 0.08726646259971647 * sin((sine + 7.5) * 0.2), -3.1590459461097367 + -0.08726646259971647 * sin(sine * 0.2)), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(-1, 1.5 + 0.5 * sin((sine + 10) * 0.2), 0.3 + 0.2 * sin((sine + -10) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin((sine + 15) * 0.2), 0, -0.08726646259971647 * sin(sine * 0.2)), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(1, 1.5 + 0.5 * sin((sine + -7.5) * 0.2), 0.3 + 0.2 * sin((sine + 5) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin(sine * 0.2), 0, -0.08726646259971647 * sin(sine * 0.2)), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-1, -1.5 + 0.5 * sin((sine + -7.5) * 0.2), 0.5 + 0.2 * sin((sine + 5) * 0.2)) * euler(1.6580627893946132 + 0.17453292519943295 * sin(sine * 0.2), 0, -0.08726646259971647 * sin(sine * 0.2)), 0.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(1, -1.5 + 0.5 * sin((sine + 10) * 0.2), 0.5 + 0.2 * sin((sine + -7.5) * 0.2)) * euler(1.6580627893946132 + -0.17453292519943295 * sin(sine * 0.2), 0, -0.08726646259971647 * sin(sine * 0.2)), 0.2) 
        elseif abs(vel.Y) > 2 then -- fall
            neck.C0 = neck.C0:Lerp(cf(0, 0, 0.5) * euler(0, 0, 3.141592653589793), 0.2) 
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, -1.4, 0) * euler(3.141592653589793, 0, -3.141592653589793), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(-1, 1.5, 0.3) * euler(1.7453292519943295, 0, -0.17453292519943295), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(1, 1.5, 0.3) * euler(1.7453292519943295, 0, 0.17453292519943295), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-1, -1.5, 0.8) * euler(1.3962634015954636, 0, -0.17453292519943295), 0.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(1, -1.5, 0.8) * euler(1.3962634015954636, 0, 0.17453292519943295), 0.2) 
        else -- idle
            neck.C0 = neck.C0:Lerp(cf(0, 0, 0.5) * euler(0.08726646259971647 * sin((sine + 20) * 0.05), 0, 3.141592653589793 + 0.3490658503988659 * sin((sine + -30) * 0.025)), 0.2) 
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, -1.5 + 0.1 * sin(sine * 0.05), 0) * euler(3.141592653589793, 0, -3.1590459461097367 + 0.05235987755982989 * sin(sine * 0.025)), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(-1, 1.5, -0.1 * sin(sine * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(1, 1.5, -0.1 * sin(sine * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-1, -1.5, 0.5 + -0.1 * sin((sine + 10) * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(1, -1.5, 0.5 + -0.1 * sin((sine + 10) * 0.05)) * euler(1.5707963267948966, 0, 0.08726646259971647 * sin(sine * 0.025)), 0.2) 
        end
    end
end)

local Simscripts = Window:NewTab("Simscripts")
local SimscriptsSection = Simscripts:NewSection("Simscripts")


SimscriptsSection:NewButton("Raise a peter", "A GUI for raise a peter", function()
    _G.RedGUI = true
_G.Theme = "Dark" -- Must disable or remove _G.RedGUI to use
--Themes: Light, Dark, Mocha, Aqua and Jester

loadstring(game:HttpGet("https://raw.githubusercontent.com/CasperFlyModz/discord.gg-rips/main/RaiseaPeter.lua"))()
end)

SimscriptsSection:NewButton("Build a boat maybe?", "A GUI in a GUI for build a boat?", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/NooVster/NOOVHUB/main/Source"))()
end)

local Doorsscripts = Window:NewTab("Doorsscripts")
local DoorsscriptsSection = Doorsscripts:NewSection("Doorsscripts")

DoorsscriptsSection:NewButton("A GUI for doors :3", "A script for doors???", function()
    local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
local Window = OrionLib:MakeWindow({IntroText = "Doors GUI v1.2",Name = "Doors", HidePremium = false, SaveConfig = true, ConfigFolder = "DoorsSex"})
if game.PlaceId == 6516141723 then
    OrionLib:MakeNotification({
        Name = "Error",
        Content = "Please execute when in game, not in lobby.",
        Time = 2
    })
end
local VisualsTab = Window:MakeTab({
    Name = "Visuals",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})
local CF = CFrame.new
local LatestRoom = game:GetService("ReplicatedStorage").GameData.LatestRoom
local ChaseStart = game:GetService("ReplicatedStorage").GameData.ChaseStart
 
local KeyChams = {}
VisualsTab:AddToggle({
    Name = "Key Chams",
    Default = false,
    Flag = "KeyToggle",
    Save = true,
    Callback = function(Value)
        for i,v in pairs(KeyChams) do
            v.Enabled = Value
        end
    end    
})
 
local function ApplyKeyChams(inst)
    wait()
    local Cham = Instance.new("Highlight")
    Cham.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    Cham.FillColor = Color3.new(0.980392, 0.670588, 0)
    Cham.FillTransparency = 0.5
    Cham.OutlineColor = Color3.new(0.792156, 0.792156, 0.792156)
    Cham.Parent = game:GetService("CoreGui")
    Cham.Adornee = inst
    Cham.Enabled = OrionLib.Flags["KeyToggle"].Value
    Cham.RobloxLocked = true
    return Cham
end
 
local KeyCoroutine = coroutine.create(function()
    workspace.CurrentRooms.DescendantAdded:Connect(function(inst)
        if inst.Name == "KeyObtain" then
            table.insert(KeyChams,ApplyKeyChams(inst))
        end
    end)
end)
for i,v in ipairs(workspace:GetDescendants()) do
    if v.Name == "KeyObtain" then
        table.insert(KeyChams,ApplyKeyChams(v))
    end
end
coroutine.resume(KeyCoroutine)
 
local BookChams = {}
VisualsTab:AddToggle({
    Name = "Book Chams",
    Default = false,
    Flag = "BookToggle",
    Save = true,
    Callback = function(Value)
        for i,v in pairs(BookChams) do
            v.Enabled = Value
        end
    end    
})
 
local FigureChams = {}
VisualsTab:AddToggle({
    Name = "Figure Chams",
    Default = false,
    Flag = "FigureToggle",
    Save = true,
    Callback = function(Value)
        for i,v in pairs(FigureChams) do
            v.Enabled = Value
        end
    end
})
 
local function ApplyBookChams(inst)
    if inst:IsDescendantOf(game:GetService("Workspace").CurrentRooms:FindFirstChild("50")) and game:GetService("ReplicatedStorage").GameData.LatestRoom.Value == 50 then
        wait()
        local Cham = Instance.new("Highlight")
        Cham.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        Cham.FillColor = Color3.new(0, 1, 0.749019)
        Cham.FillTransparency = 0.5
        Cham.OutlineColor = Color3.new(0.792156, 0.792156, 0.792156)
        Cham.Parent = game:GetService("CoreGui")
        Cham.Enabled = OrionLib.Flags["BookToggle"].Value
        Cham.Adornee = inst
        Cham.RobloxLocked = true
        return Cham
    end
end
 
local function ApplyEntityChams(inst)
    wait()
    local Cham = Instance.new("Highlight")
    Cham.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    Cham.FillColor = Color3.new(1, 0, 0)
    Cham.FillTransparency = 0.5
    Cham.OutlineColor = Color3.new(0.792156, 0.792156, 0.792156)
    Cham.Parent = game:GetService("CoreGui")
    Cham.Enabled = OrionLib.Flags["FigureToggle"].Value
    Cham.Adornee = inst
    Cham.RobloxLocked = true
    return Cham
end
 
local BookCoroutine = coroutine.create(function()
    task.wait(1)
    for i,v in pairs(game:GetService("Workspace").CurrentRooms["50"].Assets:GetDescendants()) do
        if v.Name == "LiveHintBook" then
            table.insert(BookChams,ApplyBookChams(v))
        end
    end
end)
local EntityCoroutine = coroutine.create(function()
    local Entity = game:GetService("Workspace").CurrentRooms["50"].FigureSetup:WaitForChild("FigureRagdoll",5)
    Entity:WaitForChild("Torso",2.5)
    table.insert(FigureChams,ApplyEntityChams(Entity))
end)
 
 
local GameTab = Window:MakeTab({
    Name = "Game",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})
local CharTab = Window:MakeTab({
    Name = "Character",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})
 
local TargetWalkspeed
CharTab:AddSlider({
    Name = "Speed",
    Min = 0,
    Max = 50,
    Default = 5,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    Callback = function(Value)
        TargetWalkspeed = Value
    end    
})
 
local pcl = Instance.new("SpotLight")
pcl.Brightness = 1
pcl.Face = Enum.NormalId.Front
pcl.Range = 90
pcl.Parent = game.Players.LocalPlayer.Character.Head
pcl.Enabled = false
 
 
CharTab:AddToggle({
    Name = "Headlight",
    Default = false,
    Callback = function(Value)
        pcl.Enabled = Value
    end
})
 
GameTab:AddToggle({
    Name = "No seek arms/obstructions",
    Default = false,
    Flag = "NoSeek",
    Save = true
})
 
GameTab:AddToggle({
    Name = "Instant Interact",
    Default = false,
    Flag = "InstantToggle",
    Save = true
})
GameTab:AddButton({
    Name = "Skip level",
    Callback = function()
        pcall(function()
            local HasKey = false
            local CurrentDoor = workspace.CurrentRooms[tostring(game:GetService("ReplicatedStorage").GameData.LatestRoom.Value)]:WaitForChild("Door")
            for i,v in ipairs(CurrentDoor.Parent:GetDescendants()) do
                if v.Name == "KeyObtain" then
                    HasKey = v
                end
            end
            if HasKey then
                game.Players.LocalPlayer.Character:PivotTo(CF(HasKey.Hitbox.Position))
                wait(0.3)
                fireproximityprompt(HasKey.ModulePrompt,0)
                game.Players.LocalPlayer.Character:PivotTo(CF(CurrentDoor.Door.Position))
                wait(0.3)
                fireproximityprompt(CurrentDoor.Lock.UnlockPrompt,0)
            end
            if LatestRoom == 50 then
                CurrentDoor = workspace.CurrentRooms[tostring(LatestRoom+1)]:WaitForChild("Door")
            end
            game.Players.LocalPlayer.Character:PivotTo(CF(CurrentDoor.Door.Position))
            wait(0.3)
            CurrentDoor.ClientOpen:FireServer()
        end)
    end    
})
 
GameTab:AddToggle({
    Name = "Auto skip level",
    Default = false,
    Save = false,
    Flag = "AutoSkip"
})
 
local AutoSkipCoro = coroutine.create(function()
        while true do
            task.wait()
            pcall(function()
            if OrionLib.Flags["AutoSkip"].Value == true and game:GetService("ReplicatedStorage").GameData.LatestRoom.Value < 100 then
                local HasKey = false
                local LatestRoom = game:GetService("ReplicatedStorage").GameData.LatestRoom.Value
                local CurrentDoor = workspace.CurrentRooms[tostring(LatestRoom)]:WaitForChild("Door")
                for i,v in ipairs(CurrentDoor.Parent:GetDescendants()) do
                    if v.Name == "KeyObtain" then
                        HasKey = v
                    end
                end
                if HasKey then
                    game.Players.LocalPlayer.Character:PivotTo(CF(HasKey.Hitbox.Position))
                    task.wait(0.3)
                    fireproximityprompt(HasKey.ModulePrompt,0)
                    game.Players.LocalPlayer.Character:PivotTo(CF(CurrentDoor.Door.Position))
                    task.wait(0.3)
                    fireproximityprompt(CurrentDoor.Lock.UnlockPrompt,0)
                end
                if LatestRoom == 50 then
                    CurrentDoor = workspace.CurrentRooms[tostring(LatestRoom+1)]:WaitForChild("Door")
                end
                game.Players.LocalPlayer.Character:PivotTo(CF(CurrentDoor.Door.Position))
                task.wait(0.3)
                CurrentDoor.ClientOpen:FireServer()
            end
        end)
        end
end)
coroutine.resume(AutoSkipCoro)
 
GameTab:AddButton({
    Name = "No jumpscares",
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage").Bricks.Jumpscare:Destroy()
        end)
    end    
})
GameTab:AddToggle({
    Name = "Avoid Rush/Ambush",
    Default = false,
    Flag = "AvoidRushToggle",
    Save = true
})
GameTab:AddToggle({
    Name = "No Screech",
    Default = false,
    Flag = "ScreechToggle",
    Save = true
})
 
GameTab:AddToggle({
    Name = "Always win heartbeat",
    Default = false,
    Flag = "HeartbeatWin",
    Save = true
})
 
GameTab:AddToggle({
    Name = "Predict chases",
    Default = false,
    Flag = "PredictToggle" ,
    Save = true
})
GameTab:AddToggle({
    Name = "Notify when mob spawns",
    Default = false,
    Flag = "MobToggle" ,
    Save = true
})
GameTab:AddButton({
    Name = "Complete breaker box minigame",
    Callback = function()
        game:GetService("ReplicatedStorage").Bricks.EBF:FireServer()
    end    
})
GameTab:AddButton({
    Name = "Skip level 50",
    Callback = function()
        local CurrentDoor = workspace.CurrentRooms[tostring(LatestRoom+1)]:WaitForChild("Door")
        game.Players.LocalPlayer.Character:PivotTo(CF(CurrentDoor.Door.Position))
    end    
})
GameTab:AddParagraph("Warning","You may need to open/close the panel a few times for this to work, fixing soon.")
 
--// ok actual code starts here
 
game:GetService("RunService").RenderStepped:Connect(function()
    pcall(function()
        if game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude > 0 then
            game.Players.LocalPlayer.Character:TranslateBy(game.Players.LocalPlayer.Character.Humanoid.MoveDirection * TargetWalkspeed/50)
        end
    end)
end)
 
game:GetService("Workspace").CurrentRooms.DescendantAdded:Connect(function(descendant)
    if OrionLib.Flags["NoSeek"].Value == true and descendant.Name == ("Seek_Arm" or "ChandelierObstruction") then
        task.spawn(function()
            wait()
            descendant:Destroy()
        end)
    end
end)
 
game:GetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(prompt)
    if OrionLib.Flags["InstantToggle"].Value == true then
        fireproximityprompt(prompt)
    end
end)
 
local old
old = hookmetamethod(game,"__namecall",newcclosure(function(self,...)
    local args = {...}
    local method = getnamecallmethod()
    
    if tostring(self) == 'Screech' and method == "FireServer" and OrionLib.Flags["ScreechToggle"].Value == true then
        args[1] = true
        return old(self,unpack(args))
    end
    if tostring(self) == 'ClutchHeartbeat' and method == "FireServer" and OrionLib.Flags["HeartbeatWin"].Value == true then
        args[2] = true
        return old(self,unpack(args))
    end
    
    return old(self,...)
end))
 
workspace.CurrentCamera.ChildAdded:Connect(function(child)
    if child.Name == "Screech" and OrionLib.Flags["ScreechToggle"].Value == true then
        child:Destroy()
    end
end)
 
local NotificationCoroutine = coroutine.create(function()
    LatestRoom.Changed:Connect(function()
        if OrionLib.Flags["PredictToggle"].Value == true then
            local n = ChaseStart.Value - LatestRoom.Value
            if 0 < n and n < 4 then
                OrionLib:MakeNotification({
                    Name = "Warning!",
                    Content = "Event in " .. tostring(n) .. " rooms.",
                    Time = 5
                })
            end
        end
        if OrionLib.Flags["BookToggle"].Value == true then
            if LatestRoom.Value == 50 then
                coroutine.resume(BookCoroutine)
            end
        end
        if OrionLib.Flags["FigureToggle"].Value == true then
            if LatestRoom.Value == 50 then
                coroutine.resume(EntityCoroutine)
            end
        end
    end)
    workspace.ChildAdded:Connect(function(inst)
        if inst.Name == "RushMoving" and OrionLib.Flags["MobToggle"].Value == true then
            if OrionLib.Flags["AvoidRushToggle"].Value == true then
                OrionLib:MakeNotification({
                    Name = "Warning!",
                    Content = "Avoiding Rush. Please wait.",
                    Time = 5
                })
                local OldPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                local con = game:GetService("RunService").Heartbeat:Connect(function()
                    game.Players.LocalPlayer.Character:MoveTo(OldPos + Vector3.new(0,20,0))
                end)
                
                inst.Destroying:Wait()
                con:Disconnect()
 
                game.Players.LocalPlayer.Character:MoveTo(OldPos)
            else
                OrionLib:MakeNotification({
                    Name = "Warning!",
                    Content = "Rush has spawned, hide!",
                    Time = 5
                })
            end
        elseif inst.Name == "AmbushMoving" and OrionLib.Flags["MobToggle"].Value == true then
            if OrionLib.Flags["AvoidRushToggle"].Value == true then
                OrionLib:MakeNotification({
                    Name = "Warning!",
                    Content = "Avoiding Ambush. Please wait.",
                    Time = 5
                })
                local OldPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
                local con = game:GetService("RunService").Heartbeat:Connect(function()
                    game.Players.LocalPlayer.Character:MoveTo(OldPos + Vector3.new(0,20,0))
                end)
                
                inst.Destroying:Wait()
                con:Disconnect()
                
                game.Players.LocalPlayer.Character:MoveTo(OldPos)
            else
                OrionLib:MakeNotification({
                    Name = "Warning!",
                    Content = "Ambush has spawned, hide!",
                    Time = 5
                })
            end
        end
    end)
end)
 
--// ok actual code ends here
 
local CreditsTab = Window:MakeTab({
    Name = "Credits",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})
 
CreditsTab:AddParagraph("Credits to","OminousVibes - (Got most of the ideas from their thread, check it out! - https://v3rmillion.net/showthread.php?tid=1184088)")
 
coroutine.resume(NotificationCoroutine)
 
OrionLib:Init()
 
task.wait(2)
end)



local AntiAFK = Window:NewTab("Anti AFK")
local AntiAFKSection = AntiAFK:NewSection("Anti AFK")

AntiAFKSection:NewButton("Its an anti AFK script", "just a GUI to not be AFK for a while and to not get kicked", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/2dgeneralspam1/scripts-and-stuff/master/scripts/LoadstringypVvhJBq4QNz", true))()
end)

local Cartridetroll = Window:NewTab("Cart ride troll")
local CartridetrollSection = Cartridetroll:NewSection("Cart ride troll")

CartridetrollSection:NewButton("Cart ride troll", "Cart ride troll", function()
    spawn(function()
        local message = Instance.new("Message",workspace)
        message.Text = "Loaded press z to execute inviseble , press x to respawn)"
        wait(2)
        message:Destroy()
        end)
         
         
         
         
         
         
         
         
        local mouse = game.Players.LocalPlayer:GetMouse()
         
        local groot = nil
         
        mouse.KeyDown:connect(function(k)
         
            if k == "z" then
         
         
         
        spawn(function()
        local message = Instance.new("Message",workspace)
        message.Text = "Fe Invisible Fling By Diemiers#4209 Loaded (wait 11 seconds to load)"
        wait(11)
        message:Destroy()
        end)
         
         
        local ch = game.Players.LocalPlayer.Character
        local prt=Instance.new("Model", workspace)
        local z1 =  Instance.new("Part", prt)
        z1.Name="Torso"
        z1.CanCollide = false
        z1.Anchored = true
        local z2  =Instance.new("Part", prt)
        z2.Name="Head"
        z2.Anchored = true
        z2.CanCollide = false
        local z3 =Instance.new("Humanoid", prt)
        z3.Name="Humanoid"
        z1.Position = Vector3.new(0,9999,0)
        z2.Position = Vector3.new(0,9991,0)
         game.Players.LocalPlayer.Character=prt
        wait(5)
        game.Players.LocalPlayer.Character=ch
        wait(6)
         
         
        local plr = game.Players.LocalPlayer
        mouse = plr:GetMouse()
         
        local Hum = Instance.new("Humanoid")
        Hum.Parent = game.Players.LocalPlayer.Character
         
         
        local root =  game.Players.LocalPlayer.Character.HumanoidRootPart
         
         
        for i,v in pairs(plr.Character:GetChildren()) do
         
            if v ~= root and  v.Name ~= "Humanoid" then
         
                v:Destroy()
         
            end
         
         
        end
         
        workspace.CurrentCamera.CameraSubject = root
         
        local se = Instance.new("SelectionBox",root)
        se.Adornee = root
         
         
        game:GetService('RunService').Stepped:connect(function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CanCollide = false
        end)
        game:GetService('RunService').RenderStepped:connect(function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CanCollide = false
        end)
         
         
        power = 999999 -- change this to make it more or less powerful
         
        power = power*10
         
        ---
        wait(.1)
        local bambam = Instance.new("BodyThrust")
        bambam.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
        bambam.Force = Vector3.new(power,0,power)
        bambam.Location = game.Players.LocalPlayer.Character.HumanoidRootPart.Position 
         
         
         
         
         
        local plr = game.Players.LocalPlayer
        local torso = root
        local flying = true
        local deb = true
        local ctrl = {f = 0, b = 0, l = 0, r = 0}
        local lastctrl = {f = 0, b = 0, l = 0, r = 0}
        local maxspeed = 120
        local speed = 15
         
         
        ---local bambam = Instance.new("BodyThrust")
        ---bambam.Parent = torso
        --bambam.Force = Vector3.new(9999999,0,9999999)
        --bambam.Location = torso.Position
         
         
        ---
        groot = root
         
        function Fly()
        local bg = Instance.new("BodyGyro", torso)
        bg.P = 9e4
        bg.maxTorque = Vector3.new(0, 0, 0)
        bg.cframe = torso.CFrame
        local bv = Instance.new("BodyVelocity", torso)
        bv.velocity = Vector3.new(0,0,0)
        bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
        repeat wait()
         
        if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
        speed = speed+.2
        if speed > maxspeed then
        speed = maxspeed
        end
        elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
        speed = speed-1
        if speed < 0 then
        speed = 0
        end
        end
        if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
        lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
        elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
        bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
        else
        bv.velocity = Vector3.new(0,0.1,0)
        end
         
        until not flying
        ctrl = {f = 0, b = 0, l = 0, r = 0}
        lastctrl = {f = 0, b = 0, l = 0, r = 0}
        speed = 0
        bg:Destroy()
        bv:Destroy()
         
        end
        mouse.KeyDown:connect(function(key)
        if key:lower() == "e" then
        if flying then flying = false
        else
        flying = true
        Fly()
        end
        elseif key:lower() == "w" then
        ctrl.f = 1
        elseif key:lower() == "s" then
        ctrl.b = -1
        elseif key:lower() == "a" then
        ctrl.l = -1
        elseif key:lower() == "d" then
        ctrl.r = 1
        end
        end)
        mouse.KeyUp:connect(function(key)
        if key:lower() == "w" then
        ctrl.f = 0
        elseif key:lower() == "s" then
        ctrl.b = 0
        elseif key:lower() == "a" then
        ctrl.l = 0
        elseif key:lower() == "d" then
        ctrl.r = 0
        elseif key:lower() == "r" then
         
        end
        end)
        Fly()
         
         
         
            elseif k == "x" then
         
         
                spawn(function()
        local message = Instance.new("Message",workspace)
        message.Text = "Respawning dont spam"
        wait(1)
        message:Destroy()
        end)
         
                local saved = groot.Position
         
        local ch = game.Players.LocalPlayer.Character
        local prt=Instance.new("Model", workspace)
        local z1 =  Instance.new("Part", prt)
        z1.Name="Torso"
        z1.CanCollide = false
        z1.Anchored = true
        local z2  =Instance.new("Part", prt)
        z2.Name="Head"
        z2.Anchored = true
        z2.CanCollide = false
        local z3 =Instance.new("Humanoid", prt)
        z3.Name="Humanoid"
        z1.Position = Vector3.new(0,9999,0)
        z2.Position = Vector3.new(0,9991,0)
         game.Players.LocalPlayer.Character=prt
        wait(5)
         game.Players.LocalPlayer.Character=ch
        local poop = nil
                repeat wait() poop = game.Players.LocalPlayer.Character:FindFirstChild("Head") until poop ~= nil
                wait(1)
                game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(saved)
         
            end
         
         
        end)
end)

local BloxFruits = Window:NewTab("Blox Fruits")
local BloxFruitsSection = BloxFruits:NewSection("Blox Fruits")


BloxFruitsSection:NewButton("Blox fruits GUI 1", "Why did you click on this?", function()
    loadstring(game:HttpGet"https://raw.githubusercontent.com/xDepressionx/Free-Script/main/AllScript.lua")()
end)


BloxFruitsSection:NewButton("Blox fruits GUI 2", "Why did you click on this?", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/RimuruScripter/Zama-Hub/main/LoadingScriptNew"))()
end)


BloxFruitsSection:NewButton("Blox fruits GUI 3", "Why did you click on this?", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hajibeza/RIPPER-HUB/main/RIPPERHUBV2.lua"))()
end)


BloxFruitsSection:NewButton("Blox fruits GUI 4", "Why did you click on this?", function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/NinoGod/NetnaYay/8d21ce23346c500c93bb8b4a71f7791e4058a70b/startload.lua'))()
end)


